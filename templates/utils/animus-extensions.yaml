---
kind: AnimusExtensionTemplate
version: v1
metadata:
  name: cli-input-prompt-v1
  skipDeleteAll: true
  executeOnlyOnceOnApply: true
  executeOnlyOnceOnDelete: true
spec:
  description: |
    This manifest, when applied, will prompt a user for some input.

    May have some use where a user needs to supply information, but in these scenarios it will be hard to automate such a process.
  kind: CliInputPrompt
  version: v1
  versionChangelog: |
    This is the initial version
  supportedVersions:
  - 'v1'
  baseClass: ManifestBase
  pipRequirements:
  - 'py-animus'
  importStatements:
  - 'from py_animus.manifest_management import *''
  - 'from py_animus import get_logger'
  - 'import traceback'
  - 'from getpass import getpass'
  specFields:
  - fieldName: promptText
    fieldDescription: |
      The text to display on screen
    fieldType: str
    fieldRequired: false
    fieldDefaultValue: ''
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: promptCharacter
    fieldDescription: |
      The character for the actual prompt
    fieldType: str
    fieldRequired: false
    fieldDefaultValue: '> '
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='Maximum length enforcement for promptCharacter', level='debug')
      if len(self.spec['promptCharacter']) > 64:
        self.log(message='Maximum length of 64 characters exceeded for promptCharacter', level='warning')
        self.spec['promptCharacter'] = '> '
  - fieldName: valueExpires
    fieldDescription: |
        If set to true, the value will expire after `spec.valueTTL` seconds
    fieldType: bool
    fieldRequired: false
    fieldDefaultValue: false
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for valueExpires', level='debug')
  - fieldName: valueTTL
    fieldDescription: |
      If `spec.valueExpires` is used, use this value to fine tune the exact timeout period in seconds
    fieldType: int
    fieldRequired: false
    fieldDefaultValue: 60
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for valueTTL', level='debug')
  - fieldName: convertEmptyInputToNone
    fieldDescription: |
      If input is empty, convert the final value to NoneType
    fieldType: bool
    fieldRequired: false
    fieldDefaultValue: true
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for convertEmptyInputToNone', level='debug')
  - fieldName: maskInput
    fieldDescription: |
      If true, do not echo characters. This is suitable to ask for a password, for example
    fieldType: bool
    fieldRequired: false
    fieldDefaultValue: false
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for maskInput', level='debug')
  - fieldName: containsCredentials
    fieldDescription: |
      If true, set the `for_logging=True` parameter for the `Variable` holding the final value
    fieldType: bool
    fieldRequired: false
    fieldDefaultValue: false
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for containsCredentials', level='debug')
---
kind: AnimusExtensionTemplate
version: v1
metadata:
  name: shell-script-v1
  skipDeleteAll: false          # TODO: Once the implementation is done, we can set this to `true`
  executeOnlyOnceOnApply: true
  executeOnlyOnceOnDelete: true
spec:
  description: |
    Executes a shell script.

    Output from STDOUT will be stored in a `Variable` with `:STDOUT` appended to the 
    variable name

    Output from STDERR will be stored in a `Variable` with `:STDERR` appended to the
    variable name

    Both STDOUT and STDERR will be stored as strings. No output will result in an
    empty sting.

    The exit status will be stored in a `Variable` with `:EXIT_CODE` appended to the
    variable name
  kind: ShellScript
  version: v1
  versionChangelog: |
    This is the initial version
  supportedVersions:
  - 'v1'
  baseClass: ManifestBase
  pipRequirements:
  - 'py-animus'
  importStatements:
  - 'from py_animus.manifest_management import *'
  - 'from py_animus import get_logger'
  - 'import traceback'
  - 'from pathlib import Path'
  specFields:
  - fieldName: shellInterpreter
    fieldDescription: |
      The shell interpreter to select in the shabang line. Supported values: `sh`, `zsh`, `perl`, `python` and `bash`
    fieldType: str
    fieldRequired: false
    fieldDefaultValue: 'sh'
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      SUPPORTED_SHELLS = ('sh','zsh','bash','perl','python',)
      self.log(message='Validating shabang type', level='debug')
      if self.spec['promptCharacter'] not in SUPPORTED_SHELLS:
        raise Exception('Unsupported shell. Must be one of {}'.format(SUPPORTED_SHELLS))
  - fieldName: source.type
    fieldDescription: |
      Select the source type, which can be either `filePath` that points to an 
      existing script file on the local file system, or `inLine` with the script 
      source defined in the `spec.source.value` field
    fieldType: str
    fieldRequired: false
    fieldDefaultValue: 'inLine'
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      SUPPORTED_TYPES = ('inLine', 'filePath',)
      self.log(message='Validating source.type value', level='debug')
      if self.spec['source']['type'] not in SUPPORTED_TYPES:
        raise Exception('Unsupported `spec.source.value`. Must be one of {}'.format(SUPPORTED_TYPES))
  - fieldName: source.value
    fieldDescription: |
      If `spec.source.type` has a value of `inLine` then the value here will be 
      assumed to be the script content of that type. if `spec.source.type` has a value
      of `filePath` then this value must point to an existing file on the local filesystem
    fieldType: str
    fieldRequired: false
    fieldDefaultValue: 'echo "Not Yet Implemented"'
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      if self.spec['source']['type'] == 'filePath':
        script_file = Path(self.spec['source']['value'])
        if script_file.is_file() is False:
            raise Exception('Expected file "{}" to exist'.format(self.spec['source']['value']))
      
