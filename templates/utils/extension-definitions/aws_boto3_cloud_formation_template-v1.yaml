---
kind: AnimusExtensionTemplate
version: v1
metadata:
  name: aws_boto3_cloud_formation_template-v1
  skipDeleteAll: false # FIXME deletre when done
  executeOnlyOnceOnApply: true
  executeOnlyOnceOnDelete: true
spec:
  description: |
    Creates a new stack or applies a changeset in AWS CloudFormation.

    When called with "apply" does one of two actions (default):

    1. If the template has not been applied before, apply the new template
    2. If the template was applied before, create and apply a change set

    The behavior can be fine tuned with the `spec.changeDetection` settings

    Variables to be set:

    * `FINAL_STATUS` - string with the final CLoudFormation status
    * `LOCAL_TEMPLATE_CHECKSUM` - string with the SHA256 checksum of the template in the local file (processed template - not the file checksum)
    * `REMOTE_TEMPLATE_CHECKSUM` - string with the SHA256 checksum of the remote template (processed template - not the raw string checksum)
    * And any additional mappings as defined in `spec.variableMappings`

    The following CloudFormation status codes is assumed to indicate that the stack deployment is complete:

    * `CREATE_COMPLETE`
    * `CREATE_FAILED`
    * `DELETE_COMPLETE`
    * `DELETE_FAILED`
    * `ROLLBACK_COMPLETE`
    * `ROLLBACK_FAILED`
    * `UPDATE_COMPLETE`
    * `UPDATE_FAILED`
    * `UPDATE_ROLLBACK_COMPLETE`
    * `UPDATE_ROLLBACK_FAILED`
    * `IMPORT_ROLLBACK_FAILED`
    * `IMPORT_ROLLBACK_COMPLETE`

    References:

    * https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudformation.html
    * https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-describing-stacks.html
  kind: AwsBoto3CloudFormationTemplate
  version: v1
  versionChangelog: |
    This is the initial version
  supportedVersions:
  - 'v1'
  baseClass: ManifestBase
  # outputPaths:
  #   doc: /tmp/aws_boto3_cloud_formation_template-v1/doc
  #   examples: /tmp/aws_boto3_cloud_formation_template-v1/examples
  #   implementations: /tmp/aws_boto3_cloud_formation_template-v1/impl
  pipRequirements:
  - 'py-animus'
  importStatements:
  - 'from py_animus.manifest_management import *'
  - 'from py_animus import get_logger, get_utc_timestamp'
  - 'import re'
  - 'import boto3'
  - 'import hashlib'
  - 'import json'
  specFields:
  - fieldName: awsBoto3SessionReference
    fieldDescription: |
      The AWS credentials to use for this template. The value is the "name" of the relevant "AwsBoto3Session" manifest to use
    fieldType: string
    fieldRequired: true
    fieldDefaultValue: None
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: tagReferences
    fieldDescription: |
      Reference to the names of a "AwsBoto3CloudFormationTemplateTags" manifests. All tags from these references will be added to the CloudFormation template
    fieldType: list
    fieldRequired: false
    fieldDefaultValue: []
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: parameterReferences
    fieldDescription: |
      Reference to the names of  "AwsBoto3CloudFormationTemplateParameters" manifests. All parameters from these references will be added to the CloudFormation template
    fieldType: list
    fieldRequired: false
    fieldDefaultValue: []
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: templatePath
    fieldDescription: |
      Path to the CloudFormation file. The file must be on the local filesystem. If the file is in a Git repository,
      first use "GitRepo" to get the files onto the local system (as an example)
    fieldType: string
    fieldRequired: true
    fieldDefaultValue: null
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: options.disableRollback
    fieldDescription: 'Maps to "DisableRollback" option in the AWS API'
    fieldType: boolean
    fieldRequired: false
    fieldDefaultValue: false
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: options.timeoutInMinutes
    fieldDescription: 'Maps to "TimeoutInMinutes" option in the AWS API'
    fieldType: integer
    fieldRequired: false
    fieldDefaultValue: 600
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: options.notificationARNs
    fieldDescription: 'Maps to "NotificationARNs" option in the AWS API'
    fieldType: list
    fieldRequired: false
    fieldDefaultValue: []
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: options.capabilities
    fieldDescription: |
      'Maps to "Capabilities" option in the AWS API. If supplied, can be "CAPABILITY_IAM" and/or "CAPABILITY_NAMED_IAM"
      and/or "CAPABILITY_AUTO_EXPAND"'
    fieldType: list
    fieldRequired: false
    fieldDefaultValue: []
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: options.onFailure
    fieldDescription: 'Default "ROLLBACK". If supplied, one of "DO_NOTHING" or "ROLLBACK" or "DELETE"'
    fieldType: string
    fieldRequired: false
    fieldDefaultValue: ROLLBACK
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: options.enableTerminationProtection
    fieldDescription: 'Maps to "EnableTerminationProtection" option in the AWS API'
    fieldType: boolean
    fieldRequired: false
    fieldDefaultValue: false
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: changeDetection.features.remoteTemplateValueEvaluation
    fieldDescription: |
      See https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudformation/client/get_template.html
      - the remote template will be compared with the current one.
    fieldType: boolean
    fieldRequired: false
    fieldDefaultValue: true
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: changeDetection.features.alwaysCreateChangeset
    fieldDescription: |
      Regardless if changes are present or not, create a changeset. This makes other change evaluation more or less
      redundant.
    fieldType: boolean
    fieldRequired: false
    fieldDefaultValue: false
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: changeDetection.customEvaluations.variableEvaluations
    fieldDescription: |
      Based on the value of a prior set `Variable`, a change can be assumed. Each list item is an object with the
      following fields: <ul> <li>`variableName` (string) - The name of the "Variable".</li> <li>`expectedValue`
      (string) - The Python string representation of a variable value.</li> <li>`changeDetectedIfValueMatch`
      (boolean, default=true) - If the "expectedValue" is matched, assume changes were detected. If "False" and value
      OTHER than the "expectedValue" will indicate change was detected.</li> </ul>
    fieldType: list
    fieldRequired: false
    fieldDefaultValue: []
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: raiseExceptionOnFinalStatusValues
    fieldDescription: |
      Add one or more of the following status codes that will force an exception to be raised (causing further deployment processing to stop). Possible options:
      <ul>
        <li>`CREATE_FAILED` (included in default)</li>
        <li>`DELETE_FAILED` (included in default)</li>
        <li>`ROLLBACK_FAILED` (included in default)</li>
        <li>`UPDATE_FAILED` (included in default)</li>
        <li>`UPDATE_ROLLBACK_FAILED` (included in default)</li>
        <li>`IMPORT_ROLLBACK_FAILED` (included in default)</li>
        <li>`CREATE_COMPLETE`</li>
        <li>`DELETE_COMPLETE`</li>
        <li>`ROLLBACK_COMPLETE`</li>
        <li>`UPDATE_COMPLETE`</li>
        <li>`UPDATE_ROLLBACK_COMPLETE`</li>
        <li>`IMPORT_COMPLETE`</li>
        <li>`IMPORT_ROLLBACK_COMPLETE`</li>
      </ul>
      An empty list will ignore any status
    fieldType: list
    fieldRequired: false
    fieldDefaultValue: ["CREATE_FAILED", "DELETE_FAILED", "ROLLBACK_FAILED", "UPDATE_FAILED", "UPDATE_ROLLBACK_FAILED", "IMPORT_ROLLBACK_FAILED"]
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: variableMappings.outputs
    fieldDescription: |
      Maps the template outputs to `Variable` objects. Each list item must have the following fields:
      <ul>
        <li>`variableName` (string) - The name of the "Variable", for example `INSTANCE_ID` (the other parts of the name will be automatically added)</li>
        <li>`outputKey` (string) - The value of the output key. The same as the CloudFormation output "Logical ID" for example "InstanceID"</li>
      </ul>
    fieldType: list
    fieldRequired: false
    fieldDefaultValue: []
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')
  - fieldName: variableMappings.resources
    fieldDescription: |
      Maps the created resources data to `Variable` objects. Each list item has the following structure:
      <ul>
        <li>`logicalResourceId` (string) - The value of the resource key. The same as the CloudFormation output "Logical ID" for example "InstanceID"</li>
        <li>`variables` (list) - Contains a list  of at least ONE item with the following fieldDescription:
          <ul>
            <li>`physicalResourceId` (string) - `Variable` name for storing the "PhysicalResourceId"</li>
            <li>`resourceType` (string) - `Variable` name for storing the "ResourceType"</li>
            <li>`resourceStatus` (string) - `Variable` name for storing the "ResourceStatus"</li>
          </ul>
        </li>
      </ul>
    fieldType: list
    fieldRequired: false
    fieldDefaultValue: []
    fieldSetDefaultValueConditions:
    - fieldDefinitionNotPresentInManifest: true
    - fieldValueTypeMismatch: true
    - fieldValueIsNull: true
    customValidation: |
      self.log(message='No custom validation for promptText', level='debug')